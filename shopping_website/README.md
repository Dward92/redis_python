### 购物网站的redis相关实现
----------
### 需求: ###

#### （1）登录和cookie缓存 ####
对于一个大型网上商店，假设每天都会有大约500万不同的用户，这些用户会给网站带来1亿次点击，并从网站购买超过10万件商品。

我们需要存储用户登录信息，用户的访问时长和已浏览商品的数量，如果将其保存到数据库中，会导致大量的数据库写入。

大多数关系数据库在每台数据库服务器上面每秒只能插入、更新或者删除200～2000个数据行，尽管批量操作可以以更快的速度执行，但客户点每次浏览网页都只更新少数几行数据，所以高速的批量插入在这里并不适用。

而对于负载量相对比较大的系统，譬如平均情况下每秒大约1200次写入，高峰时期每秒接近6000次写入，所以它必须部署10台关系数据库服务器才能应对高峰期的负载量。

为了提升系统的处理速度，降低资源的占用量，可以将传统数据库的一部分数据处理任务以及存储任务转交给Redis来完成。

#### （2）使用redis实现购物车 ####

我们把购物车的信息也存储到Redis，并且使用与用户会话令牌一样的cookie id来引用购物车。

* Redis设计 *
（1）登录令牌与用户映射关系的散列 "login:"
（2）记录最近登录用户的有序集合 "recent:"
（3）记录各个用户最近浏览商品的有序集合 "viewed:94233rhsYRIq3yi3qryrye" 
（4）每个用户的购物车散列，存储商品ID与商品订购数量之间的映射。"cart:94233rhsYRIq3yi3qryrye"

(94233rhsYRIq3yi3qryrye假设为某个用户的令牌)

* Redis实现 *
（1）使用散列来存储登录cookie令牌与已登录用户之前的映射。根据给定的令牌查找与之相应的用户，检查用户是否登录，并返回该用户的ID。

（2）用户每次浏览页面的时候，需要更新“登录令牌与用户映射关系的散列”里面的信息，
并将用户的令牌和当前时间戳添加到 “记录最近登录用户的有序集合” 里面，
将浏览商品添加到记录“记录各个用户最近浏览商品的有序集合”中，如果记录的商品数量超过25个，对这个有序集合进行修剪。

（3）存储会话的内存会随着时间的推移而不断增加，需要定期清理会话数据，我们决定只保留最新的1000万个会话。

我们可以用 *守护进程的方式来运行或者定义一个cron job每隔一段时间运行* ，
检查最近 “记录最近登录用户的有序集合” 大小是否超过了限制，超过限制每秒从集合中删除最旧的100个令牌，并且移除相应的“登录令牌与用户映射关系的散列”的信息和对应的“记录各个用户最近浏览商品的有序集合”。

我们也可以使用EXPIRE命令，为用户令牌设记录用户商品浏览记录的有序集合设置过期时间，让Redis在一段时间之后自动删除它们，这样就不用使用有序集合来记录最近出现的令牌了，但是这样我们就没办法将会话数限制在1000万之内了。

（4）对购物车进行更新，如果用户订购某件商品数量大于0，将商品信息添加到 “用户的购物车散列”中，如果购买商品已经存在，那么更新购买数量。



* Redis设计 *
（4）
