# 4. Redis数据安全与性能保障 #
----------

## 4.1 Redis持久化数据 ##

为了重用数据，或者防止系统故障而降数据备份到另外一个远程位置。有些数据是可能是经过长时间的计算，或者程序正在使用redis存储的数据进行计算，所以希望将这些数据存储起来，redis提供了两种不同的持久化方法将数据写入到硬盘里：

(1) 快照。将存在于某一时刻的所有数据都写入到硬盘里面。

相关的配置选项：
```
save 60 10000 #从最近一次创建快照开始算起，当60秒之内有10000次写入，就会自动触发BGSAVE命令，创建快照
stop-writes-on-bgsave-error no
rdbcompression yes
dbfilename dump.rdp # 快照被写入的指定文件
```

(2) 只追加文件。在执行写命令时，将被执行的写命令复制到硬盘里。

相关的配置选项：
```
appendonly no # 是否使用AOF持久化
appendfsync everysec # AOF文件同步频率，有几个选项
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

dir ./ # 共享选项，这个选项决定了快照文件和AOF文件的保存位置

这两种方法也可以同时使用。

### 4.1.1 快照持久化 ###

用户可以将快照复制到其他服务器创建相同数据的服务器副本，也可以将其留在原地以便重启服务器使用。

在新的快照文件创建完毕之前，如果系统，redis或者硬件中任何一个崩溃，将丢失最近一次快照写入的所有数据。

#### 创建快照的方法有以下几种：####

（1）向Redis发送一个BGSAVE的命令来创建一个快照。

Redis将fork一个子进程，用来处理将快照写入到磁盘中，父进程则继续处理命令请求。

（2）向Redis发送一个SAVE命令来创建一个快照。在创建快照完毕之前不再响应其他命令。

SAVE命令并不常用，一般在没有足够的内存去执行BGSAVE命令，或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用该命令。

（3）如果用户设置了save配置选项。
譬如 save 60 10000，即redis最近一次创建快照之后算起，当60秒之内有100000次写入这个条件被满足，redis就会自动触发BGSAVE命令.
如果用户设置了多个save配置选项，那么当任意一个save配置选项所设置的条件被满足时，redis就会触发一次BGSAVE命令。

（4）当Redis接收到SHUTDOW关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在save执行完毕后关闭服务器。

（5）当一个redis服务器连接另一个redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，主服务器会先执行BGSAVE命令。


**在新的快照文件创建完毕之前，如果系统，redis或者硬件中任何一个崩溃，将丢失最近一次生成快照之后更改的所有数据，因此，快照持久化只适用于即使丢失一部分数据也不会造成问题的应用程序。**

根据几个使用快照持久化的场景，学习如何通过修改配置来获得自己想要的快照持久化：

1. 个人开发。我们需要降低快照持久化带来的资源消耗，设置了save 900 1这一规则，距离上一次成功生成快照已经超过900秒，并且在此区间执行了至少一次写入操作，那么redis就会自动开启一次新的BGSAVE操作。
如果需要在生产服务器中使用快照持久化并存储大量数据，需要把开发环境设置尽可能贴近生产环境，有助于判断快照是否生成得过于频繁（浪费资源）或者过于稀少（有可能丢失大量数据）。

2. 对日志进行聚合计算。
对日志文件进行聚合计算或者对页面浏览量进行分析时，我们要考虑，如果Redis因为崩溃而未能成功创建新的快照，我们能够承受丢失多久时间以内产生的新数据。如果丢失一个小时以内的是可以接受的，那么我们可以配置 save 3600 1。

接下来需要解决，如何恢复因为故障而被中断的日志处理操作。可以通过将日志处理进度记录到redis里面，程序在系统崩溃之后，根据进度记录继续执行之前未完成的处理工作。

3. 大数据。
如果Redis的内存占用量达到了数据十个GB，并且剩余的空闲内存并不多，或者redis运行在虚拟机上，那么执行BGSAVE可能会导致系统长时间的停顿，也可能引发系统大量得使用虚拟内存，从而使redis性能降低到无法使用的程度。

为了防止redis因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者save来进程持久化。
手动发送BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动发送BGSAVE命令来控制手动发送BGSAVE来控制停顿时间。
另外，SAVE虽然会一直阻塞redis直至快照生成完毕，但因为它不需要创建子进程，不会出现像BGSAVE一样因为创建子进程而导致redis停顿，并因为没有子进程在争抢资源，创建快照的速度会比BGSAVE创建快照的速度来得更快。

对于大数据的redis持久化，如果程序只需要每天生成一次快照，可以写一个脚本，让她每天凌晨3点停止所有客户端对redis的访问，调动save命令并等待该命令执行完毕，之后备份刚刚生成的快照文件，并通知客户端继续执行操作。

### 4.1.2 AOF持久化 ###

AOF持久化会将执行的写命令写入到AOF文件的末尾，以此来记录数据发生的变化。因为redis只要从头到尾重新执行一次AOF文件所包含的写命令，就可以恢复AOF文件所记录的数据集。

文件同步：在硬盘写入文件时，当调用file.write()方法对文件进行写入时，写入的内容首先会被存储到缓冲区，然后操作系统会在将来的某个时候将缓冲区存储的内容写入硬盘。
用户也可以调用file.flush()方法来请求操作系统尽快将缓冲区存储的数据写入硬盘里，但具体何时执行写入操作仍然由操作系统决定。
用户还可以命令操作系统将文件同步到硬盘，同步操作会一直阻塞直到指定的文件被写入到硬盘为止。当同步操作执行完毕后，即使系统出现故障也不会对被同步的文件造成任何影响。

** AOF同步频率的几个选项：**
（1）always 
每个redis写命令都要同步写入硬盘，可以将发生系统崩溃时出现数据丢失减到最小，但需要对硬盘进行大量写入，redis处理命令的速度会受到硬盘性能的限制。

（2）everysec 每秒执行一次同步，显示地将多个写命令同步到硬盘。不会过多影响性能，也能保证即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。

（3） no 
让操作系统来决定应该何时进行同步，几乎不会对redis性能带来影响，但系统崩溃将导致使用这种选项的redis服务器丢失不定数量的数据。另外如果用户硬盘写入速度不够快，那么当缓冲区被等待写入硬盘的数据填满时，redis写入操作将被阻塞，并导致redis处理命令请求的速度变慢。因为这个原因，一般来说并不推荐使用no选项。

### 4.1.3 重写压缩AOF文件 ###

AOF持久化既然可以将丢失数据的时间窗口降低至1秒，又可以在极短时间内完成定期的持久化操作，我们有什么理由不使用AOF持久化？

（1）redis是不断将执行的写命令记录到AOF文件，随着他的不断运行，AOF的体积就会不断增长，极端情况下，AOF文件可能会用完硬盘的所有可用空间。

（2）redis重启需要将AOF文件记录的所有写命令来还原数据集，所以如果AOF文件体积非常大，那么还原操作执行的时间可能会非常长。

为了解决AOF文件体积不断增大的问题，用户可以向redis发送BGREWRITEAOF命令，通过移除AOF文件中的冗余命令来重写AOF文件，使AOF文件的体积变得尽可能地小。

BGRREWRITEAOF和BGSAVE创建快照的工作原理非常相似：redis会创建一个子进程，然后由子进程负责对AOF文件进行重写。所以在快照持久化因为创建子进程而导致性能问题和内存占用问题，在AOF持久化也同样存在。更糟糕的是，如果不加以控制，AOF文件的体积可能会比快照文件的体积大上好几倍，在进行AOF文件重写并删除旧AOF文件的时候，删除一个体积达到数十GB大的旧AOF文件可能会导致操作系统挂起数秒。

AOF可以通过设置auto-aof-rewrite-percentage选项和auto-aof-rewrite-min-size选项来自动执行BGREWRITEAOF。

例如：我们设置的配置选项如下：
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
并且启动了AOF持久化，那么当AOF文件体积大于64mb，并且AOF文件的体积比上一次重写之后的体积大了至少一倍(100%)的时候，redis将执行BGREWRITEAOF命令。
如果AOF重写过于频繁，用户可以将auto-aof-rewrite-percentage设置为100以上，让redis在AOF文件的体积变得更大之后才执行重写操作，不过会让redis重启在还原数据集所需的时间变得更长。

**除了对数据进行持久化，用户还必须对持久化文件进行备份，最好是备份到不同的地方或者不同的服务器上，尽量避免数据丢失事故的发生。**








